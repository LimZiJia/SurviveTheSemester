extends Area2D

signal stuck(safe_position: Vector2)

var area: Area2D

# Called when the node enters the scene tree for the first time.
func _ready():
	$CheckingInterval.timeout.connect(on_check_interval_timeout)
	$CheckingInterval.start()


func on_check_interval_timeout() -> void:
	check_stuck()


func check_stuck() -> void:
	var new_area = get_overlapping_areas()
	if new_area.is_empty():
		area = null
	elif area == null or area != new_area[0]:
		area = new_area[0]
	else:
		calc_safe_pos(area)


func calc_safe_pos(area: Area2D) -> void:
	if not area is WorldObject:
		return
	
	var collision_shape := area.get_child(0) as CollisionShape2D
	var rect_shape := collision_shape.shape as RectangleShape2D
	
	var buffer := 30.0
	
	# An array of the possible safe positions. Each position is generated by 
	# moving the player in one of the cardinal directions until it hits the 
	# edge of the collision shape.
	var safe_positions: Array[Vector2]
	
	for dir in [Vector2.RIGHT, Vector2.UP, Vector2.LEFT, Vector2.DOWN]:
		var safe_pos := collision_shape.global_position
		if dir.x:
			safe_pos += dir * (rect_shape.size.x / 2 + buffer)
			safe_pos.y = global_position.y
		else:
			safe_pos += dir * (rect_shape.size.y / 2 + buffer)
			safe_pos.x = global_position.x
		safe_positions.append(safe_pos)
	
	# Sort the directions based on the shortest distance
	safe_positions.sort_custom(func(a: Vector2, b: Vector2) -> bool:
		var a_dist_squared = global_position.distance_squared_to(a)
		var b_dist_squared = global_position.distance_squared_to(b)
		return a_dist_squared < b_dist_squared)
	
	# Filter any directions that move the player through the wall
	var space_state = get_world_2d().direct_space_state
	
	safe_positions = safe_positions.filter(func(safe_pos: Vector2) -> bool:
		var query = PhysicsRayQueryParameters2D.create(global_position,
		safe_pos, 0b1, [self])
		return space_state.intersect_ray(query).is_empty())
	
	if safe_positions.size() == 0:
		# Should not reach here
		return
	
	stuck.emit(safe_positions[0])
